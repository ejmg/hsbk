* section exercises for ch2
** 2.5 Evaluation
   1. Given the following lines of code as they might appear in a source file, how would you change
      them to use them directly in the REPL?
      #+BEGIN_SRC haskell
        -- will not compile because let syntax is obv for repl

        -- half x = x / 2
        let half x = x / 2

        -- square x = x * x
        let square x = x * x
      #+END_SRC

   2. Write one function that has one parameter and works for all the following expressions. Be sure
      to name the function.
      #+BEGIN_SRC haskell
        -- 3.14 * (5 * 5)
        -- 3.14 * (10 * 10)
        -- 3.14 * (2 * 2)
        -- 3.14 * (4 * 4)

        productOfPie x = 3.14 * x
      #+END_SRC

   3. There is a value in Prelude called pi. Rewrite your function to use pi instead of 3.14.
      #+BEGIN_SRC haskell
      productOfPie x = pi * x
      #+END_SRC
** 2.6 Infix operators
   Below are some pairs of functions that are alike except for parenthesization. Read them carefully
   and decide if the parentheses change the results of the function. Check your work in GHCi.

   #+BEGIN_SRC haskell
     -- a) 8 + 7 * 9
     -- b) (8 + 7) * 9
     -- absolutely, PEMDAS
     > 8 + 7 * 9
     71
     > (8 + 7) * 9
     135

     -- a) perimeter x y = (x * 2) + (y * 2)
     -- b) perimeter x y = x * 2 + y * 2
     -- Nope. Same behavior because of order of operations, mult > add 
     > perimeter 2 2

     -- a) f x = x / 2 + 9
     -- b) f x = x / (2 + 9)
     -- yes. Parent let addition occur before division.
     > f 2
     10
     > f 2
     2/11
   #+END_SRC
** 2.6 Declaring Values
   The following code samples are broken and won’t compile. The first two are as you might enter
   into the REPL; the third is from a source file. Find the mistakes and fix them so that they will.

   #+BEGIN_SRC haskell
   -- let area x = 3. 14 * (x * x)
   area x = 3.14 * (x * x)

   -- let double x = b * 2
   double x = x * 2

   -- it's weird spacing issues and i'm not replicating it in a comment
   x = 7 
   y = 10
   f = x + y
   #+END_SRC

** 2.10 Let and Where
   Now for some exercises. First, determine in your head what the following expressions will return,
   then validate in the REPL:

   #+BEGIN_SRC haskell
   -- 1. let x = 5 in x
   > 5
   > x
   <interactive>:105:1: error: Variable not in scope: x
   
   -- 2. let x = 5 in x * x
   > 25

   -- 3. let x = 5; y = 6 in x * y
   > 30
   
   -- 4. let x = 3; y = 1000 in x + 3
   > 6 
   #+END_SRC

   Note that #3 could be re-written as (in a file):

   #+BEGIN_SRC haskell
   multi = x * y
     where x = 5
           y = 6
   #+END_SRC

   Rewrite with where clauses:

   #+BEGIN_SRC haskell
   -- let x = 3; y = 1000 in x * 3 + y
   multi1000 = x * 3 + y
     where x = 3
           y = 1000 

   -- let y = 10; x = 10 * 5 + y in x * 5
   multiFn = x * 5
     where y = 10
           x = 10 * 5 + y

   -- let x = 7
   --     y = negate x
   --     z = y * 10
   -- in z / x + y
   diviZ = z / x + y
     where x = 7
           y = negate x
           z = y * 10
   #+END_SRC
* End of chapter exercises

** parenthesize the following expressions to make order of operations more explicit
   
   #+BEGIN_SRC haskell
   -- 1. 2 + 2 * 3 - 1
   > 2 + (2 * 3) - 1

   -- 2. (^) 10 $ 1 + 1
   > (2) 10 $ (1 + 1)

   -- 3. 2 ^ 2 * 4 ^ 5 + 1
   > (2 ^ 2) * (4 ^ 5) + 1
   #+END_SRC

** More fun with functions

   Here is a bit of code as it might be entered into a source file. Remember that when you write
   code in a source file, the order is unimportant, but when writing code directly into the REPL the
   order does matter. Given that, look at this code and rewrite it such that it could be evaluated in
   the REPL (remember: you may need let when entering it directly into the REPL). Be sure to enter your
   code into the REPL to make sure it evaluates correctly.

   #+BEGIN_SRC haskell
     -- z = 7
     -- x = y ^ 2
     -- waxOn = x * 5
     -- y = z + 8
   
     λ> z = 7
     λ> y = z + 8
     λ> x = y ^ 2
     λ> waxOn = x * 5
     λ> waxOn
     1125
   #+END_SRC

   1. Now you have a value called waxOn in your REPL. What do you think will happen if you enter:

      #+BEGIN_SRC haskell
      -- 10 + waxOn
      1135
      
      -- (+10) waxOn
      1135

      -- (-) 15 waxOn
      -1110

      -- (-) waxOn 15
      1110
      #+END_SRC

   2. (Problem 2 was just re-typing triple) Now, what will happen if we enter this at our GHCi
      prompt? What do you think will happen first, considering what role waxOn is playing in this
      function call? Then enter it, see what does happen, and check your understanding:

      #+BEGIN_SRC haskell
      λ> let triple x = x * 3
      λ> triple waxOn
      3375
      #+END_SRC
      
   3. Rewrite waxOn as an expression with a where clause in your source file. Load it into your REPL
      and make sure it still works as expected.

      #+BEGIN_SRC haskell
      waxOn = x * 5
        where z = 7
              y = z + 8
              x = y ^ 2      
      #+END_SRC
  
   4. Rest of exercises in ChapterExercises.hs, consisted of just adding functions to file
