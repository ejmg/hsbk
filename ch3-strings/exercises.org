* section exercises
** 3.4 

   1. These lines of code are from a REPL session. Is y in scope for z?
      #+BEGIN_SRC haskell 
      Prelude> let x = 5
      Prelude> let y = 7
      Prelude> let z = x * y
      -- yes.
      #+END_SRC

   2. These lines of code are from a REPL session. Is ℎ in scope for 𝑔? Go with your gut here.
      #+BEGIN_SRC haskell
      Prelude> let f = 3
      Prelude> let g = 6 * f + h
      -- no, unless h has been defined earlier in said session.
      #+END_SRC

   3. This code sample is from a source file. Is everything we need to execute area in scope?
      #+BEGIN_SRC haskell
      area d = pi * (r * r)
      r = d / 2
      -- NO!, d is never in scope. Chris is evil for that one.
      #+END_SRC

   4. This code is also from a source file. Now are 𝑟 and 𝑑 in scope for area?
      #+BEGIN_SRC haskell
      area d = pi * (r * r)
        where r = d / 2
      -- YES, because the argument d is binded this time to d in the declaration of r!
      #+END_SRC

** 3.5 
   Read the syntax of the following functions and decide whether it will compile. Test them in your
   REPL and try to fix the syntax errors where they occur
   #+BEGIN_SRC haskell
     -- 1. ++ [1, 2, 3] [4, 5, 6]
     -- will NOT compile, fix:
     > (++) [1, 2, 3] [4, 5, 6]

     -- 2. '<3' ++ ' Haskell'
     -- compiles 

     -- 3. concat ["<3", " Haskell"]
     -- compiles
   #+END_SRC

* Chapter exercises

** Reading syntax
   1. For the following lines of code, read the syntax carefully and decide if they are written
      correctly. Test them in your REPL after you’ve decided to check your work. Correct as many as
      you can.
      #+BEGIN_SRC haskell 
        -- a) concat [[1, 2, 3], [4, 5, 6]]
        -- compiles

        -- b) ++ [1, 2, 3] [4, 5, 6]
        -- does not compile
        > (++) [1, 2, 3] [4, 5, 6]

        -- c) (++) "hello" " world"
        -- compiles

        -- d) ["hello" ++ " world]
        -- does not compile
        > "hello" ++ " world"

        -- e) 4 !! "hello"
        -- does not compile
        > "hello" !! 4
        
        -- f) (!!) "hello" 4
        -- compiles

        -- g) take "4 lovely"
        -- does not compile
        > take 4 "lovely"

        -- h) take 3 "awesome"
        -- compiles
      #+END_SRC

   2. Match the sets of code with their outputs

      #+BEGIN_SRC haskell
        -- a) concat [[1 * 6], [2 * 6], [3 * 6]]
        > [6, 12, 18]

        -- b) "rain" ++ drop 2 "elbow"
        > "rainbow"

        -- c) 10 * head [1, 2, 3]
        > 10

        -- d) (take 3 "Julie") ++ (tail "yes")
        > "Jules"

        -- e) concat [tail [1, 2, 3],
        --            tail [4, 5, 6],
        --            tail [7, 8, 9]]
        > [2, 3, 5, 6, 8, 9]
      #+END_SRC

** Building functions
   
   1. Given the list-manipulation functions mentioned in this chapter, write functions that take the
      following inputs and return the expected outputs. Do them directly in your REPL and use the
      take and drop functions you’ve already seen.

      #+BEGIN_SRC haskell
      -- a) Given
      "Curry is awesome"
      -- Return
      "Curry is awesome!"

      > let exclaim x = x ++ "!"
      
      -- b) -- Given
      "Curry is awesome!"
      -- Return
      "y"

      > let removeChar5 x = x !! 4

      -- c) -- Given
      "Curry is awesome!"
      -- Return
      "awesome!"

      > let last7 x = drop 7 x
      #+END_SRC

   2. Now take each of the above and rewrite it in a source file as a general function that could
      take different string inputs as arguments but retain the same behavior. Use a variable as the
      argument to your (named) functions. If you’re unsure how to do this, refresh your memory by
      looking at the waxOff exercise from the previous chapter and the TopOrLocal module from this
      chapter.

      #+BEGIN_SRC haskell
      exclaim :: String -> String
      exlaim x = x ++ "!"
      
      removeChar5 :: String -> String
      removeChar5 x = x !! 4

      last7 :: String -> String
      last7 x = drop 7 x
      #+END_SRC

   3. Write a function of type String -> Char which returns the third character in a String.
      Remember to give the function a name and apply it to a variable, not a specific String, so
      that it could be reused for different String inputs, as demonstrated (feel free to name the
      function something else. Be sure to fill in the type signature and fill in the function
      definition after the equals sign):

      #+BEGIN_SRC haskell
      thirdChar :: String -> Char
      thirdChar x = x !! 2
      #+END_SRC

   4. Now change that function so the string operated on is always the same and the variable
      represents the number of the letter you want to return (you can use “Curry is awesome!” as
      your string input or a different string if you prefer).
      
      #+BEGIN_SRC haskell
      removeCharAt x = "I'd just like to interject for a moment. What you’re referring to as Linux, is in fact,   GNU/Linux, or as I’ve recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called “Linux”, and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine’s resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called “Linux” distributions are really distributions of GNU/Linux." !! x
      #+END_SRC

   5. Using the take and drop functions we looked at above, see if you can write a function called
      rvrs (an abbreviation of ‘reverse’ used because there is a function called ‘reverse’ already
      in Prelude, so if you call your function the same name, you’ll get an error message). rvrs
      should take the string “Curry is awesome” and return the result “awesome is Curry.” This may
      not be the most lovely Haskell code you will ever write, but it is quite possible using only
      what we’ve learned so far. First write it as a single function in a source file. This doesn’t
      need to, and shouldn’t, work for reversing the words of any sentence. You’re expected only to
      slice and dice this particular string with take and drop

      #+BEGIN_SRC haskell
      rvrs :: String -> String
      rvrs x = drop 9 x ++ (take 4 (drop 5 x)) ++ take 5 x
      #+END_SRC

   6. Let’s see if we can expand that function into a module. Why would we want to? By expanding it into a module, we can add more functions later that can interact with each other. We can also then export it to other modules if we want to and use this code in those other modules. There are different ways you could lay it out, but for the sake of convenience, we’ll show you a sample layout so that you can fill in the blanks:

      #+BEGIN_SRC haskell
      module Reverse where

      rvrs :: String -> String
      rvrs x = drop 9 x ++ take 4 (drop 5 x) ++ take 5 x

      testStr :: String
      testStr = "Curry is awesome"

      main :: IO ()
      main = print $ rvrs testStr
      #+END_SRC
