* sections
** 5.5
   1. Given the type a -> a, which is the type for id, attempt to make a function that terminates
      successfully that does something other than returning the same value. This is impossible, but
      you should try it anyway

      #+BEGIN_SRC haskell
        -- parametricity.hs

        module Parametricity where

        f :: a -> a
        f x = x -- works, no errors

        -- f x = x + 1 -- yields error

        f2 :: a -> a -> a
        f2 x = const x

        f3:: a -> a -> a
        f3 x = flip const x
      #+END_SRC

* end of chapter exercises

** Multiple Choice

   1. C
   2. A
   3. B
   4. C

** Determine the type

   For the following functions, determine the type of the specified value. We suggest you type them
   into a file and load the contents of the file in GHCi. In all likelihood, it initially will not
   have the polymorphic types you might expect due to the monomorphism restriction. That means that
   top-level declarations by default will have a concrete type if any can be determined. You can fix
   this by setting up your file like so:

   #+BEGIN_SRC haskell
     {-# LANGUAGE NoMonomorphismRestriction #-}

     module DetermineTheType where

     -- simple example
     example = 1
   #+END_SRC

   If you had not included the NoMonomorphismRestriction extension, example would have had the type
   Integer instead of Num a => a. Do your best to determine the most polymorphic type an expression
   could have in the following

   1. All function applications return a value. Determine the value returned by these function
      applications and the type of that value.
      
      #+BEGIN_SRC haskell
        -- a) (* 9) 6
        54 -- Numeral because no need for tighter polymorphic constraint for multiplication in this expression

        -- b) head [(0,"doge"),(1,"kitteh")]
        (0, "doge") -- tuple (a, [Char]), where a is a Num,  of 2-arity

        -- c) head [(0 :: Integer ,"doge"),(1,"kitteh")]
        (0, "doge") -- same as above but a is now an Integer, so (Integer, [Char])

        -- d) if False then True else False
        False -- Bool

        -- e) length [1, 2, 3, 4, 5]
        5 -- Int, because that is the type sig of length, [a] -> Int

        -- f) (length [1, 2, 3, 4]) > (length "TACOCAT")
        False -- Bool
      #+END_SRC

   2. Given, What is the type of w?

      #+BEGIN_SRC haskell
        x = 5
        y = x + 5
        w = y * 10 -- Num!
      #+END_SRC

   3. Given, what is the type of z?
      
      #+BEGIN_SRC haskell
        x = 5
        y = x + 5
        z y = y * 10 -- Num a => a -> a, Num!
      #+END_SRC

   4. Given, what is the type of f?

      #+BEGIN_SRC haskell
        x = 5
        y = x + 5
        f = 4 / y -- Fractional!
      #+END_SRC

   5. Given,, what is the type of f?

      #+BEGIN_SRC haskell
        x = "Julie"
        y = " <3 "
        z = "Haskell"
        f = x ++ y ++ z -- f :: [Char]
      #+END_SRC

** Does it compile?

   For each set of expressions, figure out which expression, if any, causes the compiler to squawk
   at you (n.b. we do not mean literal squawking) and why. Fix it if you can.

   1. 
      
      #+BEGIN_SRC haskell
        -- bigNum = (^) 5 $ 10
        -- wahoo = bigNum $ 10 -- will not compile!, there are no arguments left to apply with bigNum!

        bigNum x = (^) 5 $ 10 + x
        wahoo = bigNum $ 10 -- yay!
      #+END_SRC

   2. 
      
       #+BEGIN_SRC haskell
         x = print
         y = print "woohoo!"
         z = x "hello world" -- compiles
       #+END_SRC

   3. 
      
       #+BEGIN_SRC haskell
         a = (+)
         b = 5
         -- c = b 10 nope, error!
         c = a 10 -- works now, partial application of a, finishes in d
         d = c 200
       #+END_SRC

   4. 
      
      #+BEGIN_SRC haskell
      e = 12 + b
      -- f = 10000 * c, nope, c is a partially applied operation
      f = 10000 * e -- perfectly valid
      #+END_SRC

** Type variable or specific type constructor?
   
   1. You will be shown a type declaration, and you should categorize each type. The choices are a
      fully polymorphic type variable, constrained polymorphic type variable, or concrete type
      constructor.

      Example:

      #+BEGIN_SRC haskell
        f :: Num a => a -> b -> Int -> Int
        --           [0]  [1]   [2]    [3]
      #+END_SRC

      Here, the answer would be: constrained polymorphic (Num) ([0]), fully polymorphic ([1]), and
      concrete ([2] and [3]).

   2. Categorize each component of the type signature as described in the previous example.

      #+BEGIN_SRC haskell
        f :: zed -> Zed -> Blah
        -- zed [0] is a fully polymorphic type variable, whereas Zed [1] and Blah [2] are both
        -- concrete type constructors
      #+END_SRC

   3. Repeat
      
      #+BEGIN_SRC haskell
        f :: Enum b => a -> b -> C
        -- a [0] is fully polymorphic type var, b is a constrained polymorphic type var, and C is a concrete
        -- type constructor
      #+END_SRC

   4. Rinse

      #+BEGIN_SRC haskell
        f :: f -> g -> C
        -- f and g are both fully polymorphic while C is concrete type constructor 
      #+END_SRC

** Write a type signature

   For the following expressions, please add a type signature. You should be able to rely on GHCi
   type inference to check your work, although you might not have precisely the same answer as GHCi
   gives (due to polymorphism, etc)

   1. While we haven’t fully explained this syntax yet, you’ve seen it in Chapter 2 and as a
      solution to an exercise in Chapter 4. This syntax is a way of destructuring a single element
      of a list by pattern matching.

      #+BEGIN_SRC haskell
        -- functionH ::
        functionH :: [a] -> a
        functionH (x:_) = x -- this is also known as the 'head' argument lmao
      #+END_SRC

   2. you kno what 2 do

      #+BEGIN_SRC haskell
        -- functionC ::
        functionC :: Ord a => a -> a -> Bool
        functionC x y =
          if (x > y) then True else False
      #+END_SRC

   3. ye boi
      
      #+BEGIN_SRC haskell
        -- functionS ::
        functionS :: (x, y) -> y
        functionS (x, y) = y
      #+END_SRC

** Given a type, write the function

   You will be shown a type and a function that needs to be written. Use the information the type
   provides to determine what the function should do. We’ll also tell you how many ways there are to
   write the function. Syntactically different but semantically equivalent implementations are not
   counted as being different. For example, writing a function one way then rewriting the
   semantically identical function but using anonymous lambda syntax does not count as two
   implementations.

   To make things a little easier, we’ll demonstrate how to solve this kind of exercise. Given:

   #+BEGIN_SRC haskell
     myFunc :: (x -> y)
     -> (y -> z)
     -> c
     -> (a, x)
     -> (a, z)
     myFunc xToY yToZ _ (a, x) = undefined
   #+END_SRC

   Talking through the above, we have a function that takes four arguments. The final result is a
   tuple with the type (a, z). It turns out, the 𝑐 argument is nowhere in our results and there’s
   nothing to do with it, so we use the underscore to ignore that. We named the two function
   arguments by their types and pattern matched on the tuple argument. The only way to get the
   second value of the tuple from the type 𝑥 to the type 𝑧 is to use both of the functions furnished
   to us. If we tried the following:

   #+BEGIN_SRC haskell
     myFunc xToY yToZ _ (a, x) =
       (a, (xToY x))
   #+END_SRC

   We would get a type error that it expected the type 𝑧 but the actual type was 𝑦. That’s because
   we’re on the right path, but not quite done yet! Accordingly, the following should typecheck:

   #+BEGIN_SRC haskell
     myFunc :: (x -> y)
       -> (y -> z)
       -> c
       -> (a, x)
       -> (a, z)

     myFunc xToY yToZ _ (a, x) =
       (a, (yToZ (xToY x)))
   #+END_SRC

   1. There is only one function definition that typechecks and doesn’t go into an infinite loop
      when you run it.

      #+BEGIN_SRC haskell
        i :: a -> a
        -- i = undefined

        i x = x
      #+END_SRC

   2. There is only one version that works.

      #+BEGIN_SRC haskell
        c :: a -> b -> a
        -- c = undefined
        c x _ = a
      #+END_SRC

   3. Given alpha equivalence are c'' and c (see above) the same thing?

      ... Yes(?) because names don't actually matter here.

      #+BEGIN_SRC haskell
      c'' :: b -> a -> b
      -- c'' = ? 
      c'' x _ = x 
      #+END_SRC

   4. Only one version that works.

      #+BEGIN_SRC haskell
        c' :: a -> b -> b
        -- c' = undefined

        c' _ x = x
      #+END_SRC

   5. There are multiple possibilities, at least two of which you’ve seen in previous chapters.

      #+BEGIN_SRC haskell
        r :: [a] -> [a]
        -- r = undefined
        r list = reverse list
        -- alternative, `tail` works
      #+END_SRC

   6. only one version will type check
      
      #+BEGIN_SRC haskell
        co :: (b -> c) -> (a -> b) -> a -> c
        -- co = undefined
        co bToC aToB a =
          (bToC (aToB a))
      #+END_SRC

   7. one version will typecheck

      #+BEGIN_SRC haskell
        a :: (a -> c) -> a -> a
        -- a = undefined
        a _ a = a
      #+END_SRC

   8. one version will typecheck

      #+BEGIN_SRC haskell
        a' :: (a -> b) -> a -> b
        -- a' = undefined
        a' aToB a = aToB a
      #+END_SRC

** Fix it

   Won’t someone take pity on this poor broken code and fix it up? Be sure to check carefully for
   things like capitalization, parentheses, and indentation.

   1. 
      
      #+BEGIN_SRC haskell
        -- given
        module sing where

        fstString :: [Char] ++ [Char]
        fstString x = x ++ " in the rain"
        sndString :: [Char] -> Char
        sndString x = x ++ " over the rainbow"
        sing = if (x > y) then fstString x or sndString y
          where x = "Singin"
                x = "Somewhere
      #+END_SRC

      corrected

      #+BEGIN_SRC haskell
        module Sing where

        fstString :: [Char] -> [Char]
        fstString x = x ++ " in the rain"

        sndString :: [Char] -> [Char]
        sndString x = x ++ " over the rainbow"

        sing = if (x > y)
          then fstString x
          else sndString y
          where x = "Singin"
                y = "Somewhere"
      #+END_SRC

   2. Now that it’s fixed, make a minor change and make it sing the other song. If you’re lucky, you’ll end up with both songs stuck in your head!

      #+BEGIN_SRC haskell
              module Sing where

        fstString :: [Char] -> [Char]
        fstString x = x ++ " in the rain"

        sndString :: [Char] -> [Char]
        sndString x = x ++ " over the rainbow"

        sing = if (x > y)
          then sndString y
          else fstString x
          where x = "Singin"
                y = "Somewhere"
      #+END_SRC

   3. 

      #+BEGIN_SRC haskell
        -- arith3broken.hs
        module Arith3Broken where

        main :: IO ()
        Main = do
          print 1 + 2
          putStrLn 10
          print (negate -1)
          print ((+) 0 blah)
            where blah = negate 1
      #+END_SRC

      corrected

      #+BEGIN_SRC haskell
        -- arith3broken.hs
        module Arith3Broken where

        main :: IO ()
        main = do
          print (1 + 2)
          putStrLn "10"
          print (negate (-1))
          print ((+) 0 blah)
            where blah = negate 1      
      #+END_SRC

** Type-Kwon-Do

   The name is courtesy of Phillip Wright.3 Thank you for the idea! The focus here is on
   manipulating terms in order to get the types to fit. This sort of exercise is something you’ll
   encounter in writing real Haskell code, so the practice will make it easier to deal with when you
   get there. Practicing this will make you better at writing ordinary code as well.

   We provide the types and bottomed out (declared as undefined) terms. Bottom and undefined will be
   explained in more detail later. The contents of the terms are irrelevant here. You’ll use only
   the declarations provided and what the Prelude provides by default unless otherwise specified.
   Your goal is to make the ???’d declaration pass the typechecker by modifying it alone.

   Here’s a worked example for how we present these exercises and how you are expected to solve them. Given the following:
   
   #+BEGIN_SRC haskell
     data Woot
     data Blah
     f :: Woot -> Blah
     f = undefined
     g :: (Blah, Woot) -> (Blah, Blah)
     g = ???
   #+END_SRC

   Here it’s 𝑔 that you’re supposed to implement; however, you can’t evaluate anything. You’re to
   only use type-checking and typeinference to validate your answers. Also note that we’re using a
   trick for defining datatypes which can be named in a type signature, but have no values. Here’s
   an example of a valid solution:

   #+BEGIN_SRC haskell
     g :: (Blah, Woot) -> (Blah, Blah)
     g (b, w) = (b, f w)
   #+END_SRC

   1. 

      #+BEGIN_SRC haskell
        f :: Int -> String
        f = undefined
        g :: String -> Char
        g = undefined
        h :: Int -> Char
        -- h = ???
        h x = g ( f x ) -- give f an int, get a str, then give g that str, recieving a Char in return
      #+END_SRC

   2. 

      #+BEGIN_SRC haskell
        data A
        data B
        data C
        q :: A -> B
        q = undefined
        w :: B -> C
        w = undefined
        e :: A -> C
        -- e = ???
        e x = q w x
      #+END_SRC

   3. 

       #+BEGIN_SRC haskell
         data X
         data Y
         data Z
         xz :: X -> Z
         xz = undefined
         yz :: Y -> Z
         yz = undefined
         xform :: (X, Y) -> (Z, Z)
         -- xform = ???

         xform (x, y) = (xz x, (yz y))
       #+END_SRC

   4. 

      #+BEGIN_SRC haskell
        munge :: (x -> y)
          -> (y -> (w, z))
          -> x
          -> w
        -- munge = ???

        munge xToY yToWZ x = fst (yToWZ (xToY x))
      #+END_SRC
