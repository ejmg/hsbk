* section exercises
** 4.3 
*** Given the following datatype, answer the following questions:
    ~data Mood = Blah | Woot deriving Show~

    The deriving Show part is not something we’ve explained yet. For now, all we’ll say is that when
    you make your own datatypes, deriving Show allows the values of that type to be printed to the
    screen. We’ll talk about it more when we talk about typeclasses in detail.

    1. What is the type constructor, or name of this type?

       _Mood_

    2. If the function requires a Mood value, what are the values you could possibly use? 
       
       _Woot_ or _Blah_

    3. We are trying to write a function changeMood to change Chris’s mood instantaneously. It
       should act like not in that, given one value, it returns the other value of the same type. So
       far, we’ve written a type signature changeMood :: Mood -> Woot. What’s wrong with that?

       The type signature uses a data value in place of the data constructor for the return type. It should be ~changeMood :: Mood -> Mood~

    4. Now we want to write the function that changes his mood. Given an input mood, it gives us the
       other one. Fix any mistakes and complete the function:

       #+BEGIN_SRC haskell
       -- exercise Mood Swing

       module Mood where

       data Mood = Blah | Woot deriving Show

       changeMood :: Mood -> Mood
       changeMood Blah = Woot
       changeMood _ = Blah
       #+END_SRC

    5. Enter all of the above — datatype (including the deriving Show bit), your corrected type
       signature, and the corrected function into a source file. Load it and run it in GHCi to make
       sure you got it right.

       Gang gang.

* chapter exercises
  
** idk first exercise
     #+BEGIN_SRC haskell
     -- given
     awesome = ["Papuchon", "curry", ":)"]
     also = ["Quake", "The Simons"]
     allAwesome = [awesome, also]
     #+END_SRC


     1. Given the definition of length above, what would the type signature be?
        How many arguments, of what type does it take? What is the type of the
        result it evaluates to?
        #+BEGIN_SRC haskell
          length :: list -> Int
          -- it takes a list, returns an int value, and it takes a *single* list argument
        #+END_SRC

     2. What are the results of the following expressions?
        #+BEGIN_SRC 
        -- a) length [1, 2, 3, 4, 5]
        5
 
        -- b) length [(1, 2), (2, 3), (3, 4)]
        3

        -- c) length allAwesome
        2

        -- d) length (concat allAwesome)
        5
        #+END_SRC

     3. Given what we know about numeric types and the type signature of length,
        look at these two expressions. One works and one returns an error.
        Determine which will return an error and why. (n.b., you will find
        Foldable t => t a representing [a], as with concat in the previous
        chapter. Again, consider Foldable t to represent a list here, even
        though list is only one of the possible types.)

        #+BEGIN_SRC haskell
        -- > 6 / 3
        -- > 6 / length [1, 2, 3]
        #+END_SRC

        - the second one will not compile because (/) is expecting a type of
          Fractional, but the type signature of length results in an Int type
          being returned. This type is a concrete value (Int) rather than, say,
          the typeclass Num which the compiler could then convert to Fractional
          for (/).

     4. How can you fix the broken code from the preceding exercise using a
        different division function/operator?
        
        #+BEGIN_SRC haskell
        > 6 `div` length [1, 2, 3]
        #+END_SRC

     5. What is the type of the expression 2 + 3 == 5? What would we expect as a
        result?
        #+BEGIN_SRC haskell
        > 2 + 3 == 5 -- it's checking for equivelancy
        #+END_SRC

     6. What is the type and expected result value of the following:
        #+BEGIN_SRC haskell
        -- let x = 5
        -- x + 3 == 5
        False -- type -> Bool 
        #+END_SRC

     7. Below are some bits of code. Which will work? Why or why not? If they
        will work, what value would these reduce to?
        #+BEGIN_SRC haskell
          -- Prelude> length allAwesome == 2
          True
          -- Prelude> length [1, 'a', 3, 'b']
          ERROR -- lists are of one type only
          -- Prelude> length allAwesome + length awesome
          5
          -- Prelude> (8 == 8) && ('b' < 'a')
          False -- latter statement resolves to False
          -- Prelude> (8 == 8) && 9
          ERROR -- double ampersand expects variables of boolean type, given one bool and one of numerical
        #+END_SRC

     8. Write a function that tells you whether or not a given String (or list) is a palindrome.
        Here you’ll want to use a function called reverse a predefined function that does what it
        sounds like.

        #+BEGIN_SRC haskell
          -- given
          > :t reverse
          reverse :: [a] -> [a]
          > reverse "blah"
          "halb"
          -- solution, bitch
          palindrome :: [a] -> [a]
          palindrome x =
            x == (reverse x)
        #+END_SRC

     9. Write a function to return the absolute value of a number using if-then-else
        
        #+BEGIN_SRC haskell
          absolute :: Num a => a -> a
          absolute x =
            if x >= 0
            then x
            else negate x
        #+END_SRC

     10. Fill in the definition of the following function, using fst and snd:
         
         #+BEGIN_SRC haskell
           -- given
           f :: (a, b) -> (c, d) -> ((b, d), (a, c))
           f x y = ((,) (snd x, snd y) (fst x, fst y))
         #+END_SRC

** Correcting Syntax
   
   In the following examples, you’ll be shown syntactically incorrect code. Type it in and try to
   correct it in your text editor, validating it with GHC or GHCi.

   1. Here, we want a function that adds 1 to the length of a string argument and returns that
      result

      #+BEGIN_SRC haskell 
        -- given
        x = (+)
        F xs = w 'x' 1
          where w = length xs

        -- correction
        x = (x)

        f xs = w `x` 1 -- back ticks and lowercase fn name
          where w = length xs
      #+END_SRC

   2. This is supposed to be the identity function, id.
      
      #+BEGIN_SRC haskell
      -- given
      \X = x
      
      -- correction
      \x -> x
      #+END_SRC

   3. When fixed, this function will return 1 from the value (1, 2)

      #+BEGIN_SRC haskell
      -- given 
      f (a b) = A
      
      -- correction
      f (a, b) = a
      #+END_SRC
